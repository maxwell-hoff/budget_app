<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Generational Network</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: #0a0a0f;
      overflow: hidden;
      color: #cde7ff;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial;
    }

    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .hud {
      position: fixed;
      top: 14px;
      left: 14px;
      background: rgba(10, 10, 15, 0.55);
      border: 1px solid rgba(120, 180, 255, 0.2);
      border-radius: 10px;
      padding: 10px 12px;
      line-height: 1.3;
      user-select: none;
      pointer-events: none;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="hud">
    Drag to rotate • Scroll to zoom • Double-click to reset • Space toggles auto-rotate
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Resize handling (with devicePixelRatio)
    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    // World/visual parameters (inspired by landing_page_viz.py)
    const GENERATION_LIMIT = 10;
    const SECTION_COUNT = 30;
    let direction = 1; // +1 right, -1 left across sections
    const MIN_CHILDREN = 1;
    const MAX_CHILDREN = 12;
    const MAX_POSITION_TRIES = 20;

    // World extents (arbitrary units projected to screen)
    const WORLD_WIDTH = 2400;  // X spans sections across this width
    const WORLD_HEIGHT = 1400; // clamp Y within this height
    const SCREEN_MARGIN = 120; // world-margin when placing nodes

    // Visuals
    const NODE_RADIUS = 3;
    const NODE_OUTER_COLOR = 'rgb(50, 200, 255)';
    const NODE_INNER_COLOR = 'rgb(0, 0, 0)';
    const INNER_FILL_PERCENT = 0.8;
    const LINE_COLOR = 'rgb(120, 120, 140)';
    const BIRTH_GLOW_DURATION_MS = 900; // glow duration for new nodes
    const GLOW_COLOR = 'rgba(50, 200, 255, 1)';

    // Animation speeds (per frame, tuned for ~60fps)
    const GROWTH_SPEED = 0.2; // 0->1 growth in ~5 frames
    const FADE_SPEED = 0.02;  // fade-out in ~50 frames
    const SPAWN_INTERVAL_FRAMES = 5;

    // Simple perspective camera + orbit controls
    const PERSPECTIVE = 1000; // focal length
    let yaw = -0.5;   // rotate around Y
    let pitch = -0.12; // rotate around X
    let zoom = 1.0;   // uniform scale
    let autoRotate = false;

    // Interaction state
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // Data structures
    class Node {
      constructor(position, section, generation, parents = []) {
        this.id = `${Date.now()}-${Math.random().toString(36).slice(2)}`;
        this.position = { x: position.x, y: position.y, z: position.z };
        this.section = section;
        this.generation = generation;
        this.parents = parents; // array of Node
        this.growth = 0.0; // 0..1 edge growth toward this node from its parents
        this.fade = 1.0;   // 1..0 visibility
        this.createdAt = performance.now(); // for birth glow
      }
    }

    let nodes = [];

    // Rotation helpers
    function rotateX(p, a) {
      const c = Math.cos(a), s = Math.sin(a);
      const y = p.y * c - p.z * s;
      const z = p.y * s + p.z * c;
      return { x: p.x, y, z };
    }
    function rotateY(p, a) {
      const c = Math.cos(a), s = Math.sin(a);
      const x = p.x * c + p.z * s;
      const z = -p.x * s + p.z * c;
      return { x, y: p.y, z };
    }

    function project(p) {
      const scale = (PERSPECTIVE * zoom) / (PERSPECTIVE + p.z);
      const cx = canvas.width / (window.devicePixelRatio || 1) / 2;
      const cy = canvas.height / (window.devicePixelRatio || 1) / 2;
      return { x: cx + p.x * scale, y: cy + p.y * scale };
    }

    // Root node at world center
    const root = new Node({ x: 0, y: 0, z: 0 }, 0, 0, []);
    root.growth = 1.0; // already visible
    nodes.push(root);

    function worldSectionBounds(sectionIndex) {
      const sectionWidth = WORLD_WIDTH / SECTION_COUNT;
      const left = -WORLD_WIDTH / 2 + sectionIndex * sectionWidth;
      const right = left + sectionWidth;
      return { left, right };
    }

    function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }
    function rand(min, max) { return min + Math.random() * (max - min); }

    function addChildren() {
      if (nodes.length === 0) return;

      const parent = nodes[nodes.length - 1];
      const parentSection = parent.section;
      let nextSection = parentSection + direction;
      if (nextSection < 0 || nextSection >= SECTION_COUNT) {
        direction *= -1;
        nextSection = parentSection + direction;
      }

      const { left, right } = worldSectionBounds(nextSection);
      const numChildren = Math.floor(rand(MIN_CHILDREN, MAX_CHILDREN + 1));

      for (let i = 0; i < numChildren; i++) {
        let childPos = null;
        for (let t = 0; t < MAX_POSITION_TRIES; t++) {
          const x = rand(clamp(left + SCREEN_MARGIN, -WORLD_WIDTH/2, WORLD_WIDTH/2),
                         clamp(right - SCREEN_MARGIN, -WORLD_WIDTH/2, WORLD_WIDTH/2));
          const y = rand(-WORLD_HEIGHT/2 + SCREEN_MARGIN, WORLD_HEIGHT/2 - SCREEN_MARGIN);
          const z = rand(-180, 180); // modest depth jitter
          childPos = { x, y, z };
          // In 2D version, edges avoid intersections. For simplicity in 3D, skip intersection tests.
          break;
        }
        const child = new Node(childPos, nextSection, parent.generation + 1, [parent]);
        nodes.push(child);
      }

      // Prune by generation limit
      let maxGen = -Infinity;
      for (const n of nodes) maxGen = Math.max(maxGen, n.generation);
      const minAliveGen = maxGen - (GENERATION_LIMIT - 1);
      nodes = nodes.filter(n => n.generation >= minAliveGen || n.fade > 0.0);
    }

    function updateAndDraw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const overlayAlphaEdges = 1.0; // per-edge alpha is handled per-node fade below

      // Auto-rotate if enabled
      if (autoRotate) yaw += 0.0022;

      // Update growth and fade
      let maxGen = -Infinity;
      for (const n of nodes) maxGen = Math.max(maxGen, n.generation);
      const minAliveGen = maxGen - (GENERATION_LIMIT - 1);

      for (const n of nodes) {
        if (n.growth < 1.0) n.growth = Math.min(1.0, n.growth + GROWTH_SPEED);
        if (n.generation < minAliveGen) {
          n.fade = Math.max(0.0, n.fade - FADE_SPEED);
        } else {
          n.fade = 1.0;
        }
      }

      // Remove fully faded nodes
      nodes = nodes.filter(n => n.fade > 0.0);

      // Precompute rotated positions for parents and children at full growth
      const rotated = new Map();
      for (const n of nodes) {
        const r1 = rotateY(n.position, yaw);
        const r2 = rotateX(r1, pitch);
        rotated.set(n.id, r2);
      }

      // Draw connections first (animated growth)
      ctx.save();
      ctx.lineWidth = 1;
      ctx.strokeStyle = LINE_COLOR;
      ctx.globalAlpha = overlayAlphaEdges;

      for (const n of nodes) {
        for (const p of n.parents) {
          // Only draw if parent is still present
          if (!nodes.includes(p)) continue;

          // Compute partially grown endpoint in world space
          const endWorld = {
            x: p.position.x + (n.position.x - p.position.x) * n.growth,
            y: p.position.y + (n.position.y - p.position.y) * n.growth,
            z: p.position.z + (n.position.z - p.position.z) * n.growth,
          };

          const parentRot = rotateX(rotateY(p.position, yaw), pitch);
          const endRot = rotateX(rotateY(endWorld, yaw), pitch);

          const a = project(parentRot);
          const b = project(endRot);

          const alpha = Math.min(n.fade, p.fade);
          if (alpha <= 0) continue;

          ctx.globalAlpha = alpha * 0.75; // soften
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.stroke();
        }
      }
      ctx.restore();

      // Draw nodes on top
      ctx.save();
      for (const n of nodes) {
        if (n.growth < 1.0) continue; // only fully grown nodes
        const pr = project(rotateX(rotateY(n.position, yaw), pitch));

        const alpha = n.fade;
        if (alpha <= 0) continue;

        // Birth glow (brief, decaying)
        const ageMs = performance.now() - (n.createdAt || 0);
        if (ageMs >= 0 && ageMs < BIRTH_GLOW_DURATION_MS) {
          const t = 1 - ageMs / BIRTH_GLOW_DURATION_MS; // 1 -> 0
          const glowRadius = NODE_RADIUS * (1.2 + 0.6 * t);
          const blur = 18 + 24 * t;
          ctx.save();
          ctx.globalAlpha = Math.min(1, alpha * (0.35 + 0.45 * t));
          ctx.fillStyle = GLOW_COLOR;
          ctx.shadowColor = GLOW_COLOR;
          ctx.shadowBlur = blur;
          ctx.beginPath();
          ctx.arc(pr.x, pr.y, glowRadius, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Outer filled circle
        ctx.globalAlpha = alpha;
        ctx.fillStyle = NODE_OUTER_COLOR;
        ctx.beginPath();
        ctx.arc(pr.x, pr.y, NODE_RADIUS, 0, Math.PI * 2);
        ctx.fill();

        // Inner fill
        const innerR = Math.max(0, NODE_RADIUS * INNER_FILL_PERCENT);
        if (innerR > 0) {
          ctx.fillStyle = NODE_INNER_COLOR;
          ctx.beginPath();
          ctx.arc(pr.x, pr.y, innerR, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.restore();
    }

    // Spawn loop similar to pygame clock/frame counter
    let frameCount = 0;
    function loop() {
      frameCount += 1;
      if (frameCount % SPAWN_INTERVAL_FRAMES === 0) addChildren();
      updateAndDraw();
      requestAnimationFrame(loop);
    }
    loop();

    // Interaction controls
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });
    window.addEventListener('mouseup', () => { isDragging = false; });
    window.addEventListener('mouseleave', () => { isDragging = false; });
    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      yaw += dx * 0.005;
      pitch += dy * 0.005;
      const maxPitch = Math.PI / 2 - 0.05;
      if (pitch > maxPitch) pitch = maxPitch;
      if (pitch < -maxPitch) pitch = -maxPitch;
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = -Math.sign(e.deltaY);
      const factor = 1 + 0.1 * delta;
      zoom *= factor;
      zoom = Math.max(0.35, Math.min(4.0, zoom));
    }, { passive: false });

    canvas.addEventListener('dblclick', () => {
      yaw = -0.5;
      pitch = -0.12;
      zoom = 1.0;
    });

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        autoRotate = !autoRotate;
      }
    });
  </script>
</body>
</html>

