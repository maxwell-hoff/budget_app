<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D Neural Network (Standalone)</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 800px at 70% 30%, #12182b 0%, #0a0f1f 60%, #070b17 100%);
      color: #ccd6f6;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }

    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    .hud {
      position: fixed;
      top: 16px;
      left: 16px;
      background: rgba(7, 11, 23, 0.6);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(99, 114, 255, 0.2);
      border-radius: 10px;
      padding: 12px 14px;
      max-width: 360px;
      line-height: 1.4;
      user-select: none;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
    }

    .hud h3 {
      margin: 0 0 8px 0;
      font-weight: 600;
      font-size: 14px;
      letter-spacing: 0.4px;
      color: #e6f1ff;
    }

    .hud .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .hud label {
      font-size: 12px;
      opacity: 0.9;
      white-space: nowrap;
    }

    .hud input[type="text"] {
      width: 180px;
      border-radius: 8px;
      border: 1px solid rgba(99, 114, 255, 0.25);
      background: rgba(18, 24, 43, 0.6);
      color: #e6f1ff;
      padding: 6px 8px;
      outline: none;
    }

    .hud button, .hud .toggle {
      border-radius: 8px;
      border: 1px solid rgba(99, 114, 255, 0.25);
      background: rgba(18, 24, 43, 0.6);
      color: #e6f1ff;
      padding: 6px 10px;
      cursor: pointer;
      font-size: 12px;
    }

    .hud .toggle.active {
      border-color: rgba(99, 214, 255, 0.6);
      box-shadow: 0 0 0 2px rgba(99, 214, 255, 0.15) inset;
    }

    .footer {
      position: fixed;
      right: 16px;
      bottom: 14px;
      color: #99a3c8;
      font-size: 12px;
      opacity: 0.9;
      user-select: none;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <div class="hud">
    <h3>3D Neural Network</h3>
    <div style="margin-bottom:8px; font-size:12px; color:#aab6ff;">
      Drag to rotate • Scroll to zoom • Double-click to reset • Space to toggle auto-rotate
    </div>
    <div class="row" style="margin-bottom:8px;">
      <label for="layers">Layers:</label>
      <input id="layers" type="text" value="5,10,8,6,3" title="Comma-separated neuron counts per layer" />
      <button id="apply">Apply</button>
    </div>
    <div class="row">
      <div id="autorotate" class="toggle">Auto-rotate</div>
      <div id="shuffle" class="toggle">Shuffle layout</div>
    </div>
    <div class="row" style="margin-top:8px;">
      <label for="connDensity">Connections/node:</label>
      <input id="connDensity" type="range" min="1" max="6" step="1" value="3" />
      <span id="connDensityValue">3</span>
    </div>
  </div>

  <div class="footer">Standalone HTML • No external libraries</div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Sizing
    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      canvas.style.width = '100vw';
      canvas.style.height = '100vh';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    // Scene state
    let layerSizes = [5, 10, 8, 6, 3];
    let nodes = [];
    let edges = [];

    // Interaction state
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let yaw = -0.5;   // rotation around Y
    let pitch = -0.12; // rotation around X
    let zoom = 1.0;   // model scale factor
    let autoRotate = false;

    // Animation state
    let time = 0;
    let nodeAnimationSpeed = 0.8;
    let connectionAnimationSpeed = 1.2;
    
    // Dynamic network state
    let maxNodesPerLayer = [];
    let nodeLifecycles = new Map(); // tracks node birth/death times
    let edgeLifecycles = new Map(); // tracks edge birth/death times
    let nodeLifetime = 8.0; // seconds a node lives
    let edgeLifetime = 6.0; // seconds an edge lives
    let spawnRate = 0.3; // probability per frame of spawning new elements

    // Connection density and styling controls
    let targetConnectionsPerNode = 3; // adjustable via HUD
    let reselectionInterval = 1.5; // seconds between reconnection passes
    let lastReselectionTime = 0;
    let forceReselectConnections = false;
    const dashFlowSpeed = 80; // pixels per second for dashed overlay
    const curvatureFactor = 0.18; // curve strength as fraction of segment length

    // Visual tuning
    const perspective = 900; // virtual focal length
    const baseNodeRadius = 6;
    const layerSpacing = 110; // world units
    const neuronVerticalSpacing = 26;
    const jitterAmount = 12; // random Z jitter for depth
    const edgeAlpha = 0.25; // Increased visibility
    const edgeWidth = 1.8; // Thicker lines

    function generatePalette(num) {
      const colors = [];
      const startHue = 220; // bluish
      const endHue = 280;   // violet
      for (let i = 0; i < num; i++) {
        const t = num <= 1 ? 0 : i / (num - 1);
        const hue = startHue + (endHue - startHue) * t;
        colors.push(`hsl(${hue}, 75%, 65%)`);
      }
      return colors;
    }

    function randomSeededNoise(seed) {
      let s = seed % 2147483647;
      if (s <= 0) s += 2147483646;
      return () => (s = s * 16807 % 2147483647) / 2147483647;
    }

    let shuffleSeed = Math.floor(Math.random() * 1e9);
    function rebuildGraph() {
      const rng = randomSeededNoise(shuffleSeed);
      nodes = [];
      edges = [];
      nodeLifecycles.clear();
      edgeLifecycles.clear();

      // Store max nodes per layer for dynamic spawning
      maxNodesPerLayer = [...layerSizes];
      
      const numLayers = layerSizes.length;
      const palette = generatePalette(numLayers);

      // Start with fewer nodes that will grow over time
      const totalWidth = (numLayers - 1) * layerSpacing;
      for (let layerIndex = 0; layerIndex < numLayers; layerIndex++) {
        const maxNeurons = layerSizes[layerIndex];
        const initialNeurons = Math.max(1, Math.floor(maxNeurons * 0.3)); // Start with 30% of max
        const layerX = -totalWidth / 2 + layerIndex * layerSpacing;

        for (let neuronIndex = 0; neuronIndex < initialNeurons; neuronIndex++) {
          const node = createNode(layerIndex, neuronIndex, layerX, palette[layerIndex], rng);
          nodes.push(node);
          nodeLifecycles.set(node.id, { birthTime: time, deathTime: time + nodeLifetime + rng() * 4 });
        }
      }

      // Create initial connections
      recomputeConnectionsDensityBased();
      lastReselectionTime = time;
    }

    function createNode(layerIndex, neuronIndex, layerX, color, rng) {
      const maxNeuronsInLayer = maxNodesPerLayer[layerIndex];
      const totalHeight = (maxNeuronsInLayer - 1) * neuronVerticalSpacing;
      const y = -totalHeight / 2 + neuronIndex * neuronVerticalSpacing;
      const zJitter = (rng() - 0.5) * 2 * jitterAmount;
      
      return {
        id: `${layerIndex}:${neuronIndex}`,
        layerIndex,
        neuronIndex,
        color: color,
        baseX: layerX,
        baseY: y,
        baseZ: zJitter,
        x: layerX,
        y: y,
        z: zJitter,
        // Animation properties
        floatOffset: rng() * Math.PI * 2,
        floatAmplitude: 3 + rng() * 4,
        opacity: 0 // Start invisible, will fade in
      };
    }

    function recomputeConnectionsDensityBased() {
      const numLayers = maxNodesPerLayer.length;
      const newEdges = [];
      const incomingCounts = new Map();

      for (let l = 0; l < numLayers - 1; l++) {
        const leftNodes = nodes.filter(n => n.layerIndex === l).sort((a,b)=>a.neuronIndex-b.neuronIndex);
        const rightNodes = nodes.filter(n => n.layerIndex === l + 1).sort((a,b)=>a.neuronIndex-b.neuronIndex);
        const L = leftNodes.length;
        const R = rightNodes.length;
        if (L === 0 || R === 0) continue;

        for (let i = 0; i < L; i++) {
          const leftNode = leftNodes[i];
          const idealRightIndex = L === 1 ? Math.floor(R/2) : Math.round(i * (R - 1) / (L - 1));
          // Build right indices in order of proximity to ideal to minimize crossings
          const orderedIndices = [];
          for (let k = 0; k < R; k++) {
            const s = Math.floor((k + 1) / 2) * (k % 2 === 0 ? 1 : -1); // 0, +1, -1, +2, -2...
            const idx = idealRightIndex + s;
            if (idx >= 0 && idx < R) orderedIndices.push(idx);
          }

          let added = 0;
          for (const idx of orderedIndices) {
            const rightNode = rightNodes[idx];
            const inCount = incomingCounts.get(rightNode.id) || 0;
            if (inCount >= targetConnectionsPerNode) continue;
            newEdges.push({ id: `${leftNode.id}->${rightNode.id}`, from: leftNode, to: rightNode });
            incomingCounts.set(rightNode.id, inCount + 1);
            added++;
            if (added >= targetConnectionsPerNode) break;
          }
        }
      }

      edges = newEdges;
    }

    function spawnNewNodes() {
      const rng = randomSeededNoise(shuffleSeed + Math.floor(time * 50));
      const numLayers = maxNodesPerLayer.length;
      const palette = generatePalette(numLayers);
      
      for (let layerIndex = 0; layerIndex < numLayers; layerIndex++) {
        const currentNodes = nodes.filter(n => n.layerIndex === layerIndex).length;
        const maxNodes = maxNodesPerLayer[layerIndex];
        
        if (currentNodes < maxNodes && rng() < spawnRate * 0.02) {
          // Find available neuron index
          const usedIndices = new Set(nodes.filter(n => n.layerIndex === layerIndex).map(n => n.neuronIndex));
          let neuronIndex = 0;
          while (usedIndices.has(neuronIndex) && neuronIndex < maxNodes) {
            neuronIndex++;
          }
          
          if (neuronIndex < maxNodes) {
            const layerX = -((numLayers - 1) * layerSpacing) / 2 + layerIndex * layerSpacing;
            const node = createNode(layerIndex, neuronIndex, layerX, palette[layerIndex], rng);
            nodes.push(node);
            nodeLifecycles.set(node.id, { 
              birthTime: time, 
              deathTime: time + nodeLifetime + rng() * 4 
            });
            forceReselectConnections = true;
          }
        }
      }
    }

    function removeExpiredElements() {
      let removedNode = false;
      // Remove expired nodes
      nodes = nodes.filter(node => {
        const lifecycle = nodeLifecycles.get(node.id);
        if (!lifecycle || time > lifecycle.deathTime) {
          nodeLifecycles.delete(node.id);
          removedNode = true;
          return false;
        }
        return true;
      });

      // Remove edges pointing to missing nodes
      const existingIds = new Set(nodes.map(n => n.id));
      edges = edges.filter(edge => existingIds.has(edge.from.id) && existingIds.has(edge.to.id));

      if (removedNode) {
        forceReselectConnections = true;
      }
    }

    function rotateX(point, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const y = point.y * cos - point.z * sin;
      const z = point.y * sin + point.z * cos;
      return { x: point.x, y, z };
    }

    function rotateY(point, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      const x = point.x * cos + point.z * sin;
      const z = -point.x * sin + point.z * cos;
      return { x, y: point.y, z };
    }

    function project(point) {
      // Perspective projection with simple camera at origin looking down -Z
      const scale = (perspective * zoom) / (perspective + point.z);
      const screenX = canvas.width / (window.devicePixelRatio || 1) / 2 + point.x * scale;
      const screenY = canvas.height / (window.devicePixelRatio || 1) / 2 + point.y * scale;
      return { x: screenX, y: screenY, scale, depth: point.z };
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function drawEdges(rotatedPositions) {
      ctx.save();
      const dashOffset = -(time * dashFlowSpeed);

      for (const edge of edges) {
        const a = rotatedPositions.get(edge.from.id);
        const b = rotatedPositions.get(edge.to.id);
        if (!a || !b) continue;
        if (a.depth < -perspective * 0.98 || b.depth < -perspective * 0.98) continue;

        // Quadratic bezier control point to create a gentle curve
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const length = Math.sqrt(dx * dx + dy * dy) || 1;
        const nx = -dy / length;
        const ny = dx / length;
        const cx = (a.x + b.x) / 2 + nx * length * curvatureFactor;
        const cy = (a.y + b.y) / 2 + ny * length * curvatureFactor;

        // Base line
        ctx.lineWidth = edgeWidth;
        ctx.globalAlpha = edgeAlpha;
        ctx.strokeStyle = 'rgba(150, 190, 255, 0.95)';
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.quadraticCurveTo(cx, cy, b.x, b.y);
        ctx.stroke();

        // Flow overlay with animated dash
        ctx.lineWidth = Math.max(1, edgeWidth - 0.6);
        ctx.globalAlpha = Math.min(1, edgeAlpha + 0.25);
        ctx.strokeStyle = 'rgba(220, 240, 255, 0.95)';
        ctx.setLineDash([10, 14]);
        ctx.lineDashOffset = dashOffset;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.quadraticCurveTo(cx, cy, b.x, b.y);
        ctx.stroke();
      }

      ctx.setLineDash([]);
      ctx.restore();
    }

    function drawNodes(projectedNodes) {
      ctx.save();
      for (const n of projectedNodes) {
        // Calculate lifecycle fade in/out
        const lifecycle = nodeLifecycles.get(n.nodeId);
        let lifecycleAlpha = 1;
        if (lifecycle) {
          const age = time - lifecycle.birthTime;
          const lifetime = lifecycle.deathTime - lifecycle.birthTime;
          const fadeTime = 1.5; // seconds to fade in/out
          
          if (age < fadeTime) {
            lifecycleAlpha = age / fadeTime; // Fade in
          } else if (age > lifetime - fadeTime) {
            lifecycleAlpha = (lifetime - age) / fadeTime; // Fade out
          }
          lifecycleAlpha = Math.max(0, Math.min(1, lifecycleAlpha));
        }
        
        // Constant radius (no size pulsing)
        const radius = Math.max(1.2, baseNodeRadius * 0.25 + baseNodeRadius * 0.75 * n.scale);
        
        // Animated glow intensity
        const glowIntensity = 0.7 + 0.3 * Math.sin(time * nodeAnimationSpeed * 0.8 + (n.floatOffset || 0));
        const shadowBlur = Math.min(24, radius * 2.5 * glowIntensity);
        
        // Node glow
        ctx.shadowColor = n.color;
        ctx.shadowBlur = shadowBlur;
        ctx.fillStyle = n.color;
        ctx.globalAlpha = (0.8 + 0.2 * glowIntensity) * lifecycleAlpha;
        
        ctx.beginPath();
        ctx.arc(n.x, n.y, radius, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }

    function render() {
      time += 0.016; // Approximate 60fps time increment
      
      if (autoRotate) {
        yaw += 0.0022;
      }

      // Dynamic network updates
      if (Math.floor(time * 10) % 3 === 0) { // Every ~0.3 seconds
        spawnNewNodes();
      }
      if (forceReselectConnections || (time - lastReselectionTime) > reselectionInterval) {
        recomputeConnectionsDensityBased();
        forceReselectConnections = false;
        lastReselectionTime = time;
      }
      removeExpiredElements();

      clearCanvas();

      // Update node positions with floating animation
      for (const n of nodes) {
        // Gentle floating motion
        const floatY = Math.sin(time * nodeAnimationSpeed + n.floatOffset) * n.floatAmplitude;
        const floatX = Math.cos(time * nodeAnimationSpeed * 0.7 + n.floatOffset) * (n.floatAmplitude * 0.3);
        const floatZ = Math.sin(time * nodeAnimationSpeed * 0.5 + n.floatOffset + 1) * (n.floatAmplitude * 0.5);
        
        n.x = n.baseX + floatX;
        n.y = n.baseY + floatY;
        n.z = n.baseZ + floatZ;
      }

      // Compute rotated, projected positions
      const rotated = new Map();
      for (const n of nodes) {
        const scaled = { x: n.x, y: n.y, z: n.z };
        let p = rotateY(scaled, yaw);
        p = rotateX(p, pitch);
        const proj = project(p);
        rotated.set(n.id, { 
          ...proj, 
          color: n.color, 
          layerIndex: n.layerIndex,
          floatOffset: n.floatOffset,
          nodeId: n.id
        });
      }

      // Draw edges behind nodes
      drawEdges(rotated);

      // Sort nodes by depth (back-to-front)
      const projectedNodes = [];
      for (const n of nodes) {
        const p = rotated.get(n.id);
        if (p) projectedNodes.push({ ...p, color: n.color });
      }
      projectedNodes.sort((a, b) => a.depth - b.depth);

      drawNodes(projectedNodes);

      requestAnimationFrame(render);
    }

    // Interaction
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });
    window.addEventListener('mouseup', () => { isDragging = false; });
    window.addEventListener('mouseleave', () => { isDragging = false; });
    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - lastMouseX;
      const dy = e.clientY - lastMouseY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      yaw += dx * 0.005;
      pitch += dy * 0.005;
      const maxPitch = Math.PI / 2 - 0.05;
      if (pitch > maxPitch) pitch = maxPitch;
      if (pitch < -maxPitch) pitch = -maxPitch;
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = -Math.sign(e.deltaY);
      const factor = 1 + 0.1 * delta;
      zoom *= factor;
      zoom = Math.max(0.3, Math.min(4.5, zoom));
    }, { passive: false });

    canvas.addEventListener('dblclick', () => {
      yaw = -0.5;
      pitch = -0.12;
      zoom = 1.0;
    });

    window.addEventListener('keydown', (e) => {
      if (e.code === 'Space') {
        autoRotate = !autoRotate;
        updateToggles();
      }
    });

    // HUD controls
    const layersInput = document.getElementById('layers');
    const applyBtn = document.getElementById('apply');
    const toggleRotateBtn = document.getElementById('autorotate');
    const shuffleBtn = document.getElementById('shuffle');
    const connDensitySlider = document.getElementById('connDensity');
    const connDensityValue = document.getElementById('connDensityValue');

    function updateToggles() {
      toggleRotateBtn.classList.toggle('active', autoRotate);
    }

    applyBtn.addEventListener('click', () => {
      const text = layersInput.value.trim();
      const parts = text.split(',').map(s => parseInt(s, 10)).filter(n => Number.isFinite(n) && n > 0);
      if (parts.length >= 2) {
        layerSizes = parts;
        rebuildGraph();
      } else {
        alert('Please enter at least two positive integers, e.g. 5,10,8,6,3');
      }
    });

    toggleRotateBtn.addEventListener('click', () => {
      autoRotate = !autoRotate;
      updateToggles();
    });

    shuffleBtn.addEventListener('click', () => {
      shuffleSeed = Math.floor(Math.random() * 1e9);
      rebuildGraph();
    });

    connDensitySlider.addEventListener('input', () => {
      targetConnectionsPerNode = parseInt(connDensitySlider.value, 10);
      connDensityValue.textContent = String(targetConnectionsPerNode);
      forceReselectConnections = true;
    });

    // Init
    rebuildGraph();
    updateToggles();
    render();
  </script>
</body>
</html>

