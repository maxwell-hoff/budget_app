<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Network Landscape - Moving Window</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: radial-gradient(1200px 800px at 50% 30%, #0e0f12, #040506 60%, #000 100%);
      color: #d0d4d8;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      overflow: hidden;
    }
    #app {
      position: fixed;
      inset: 0;
    }
    canvas { display: block; }
    .overlay {
      position: fixed;
      top: 12px;
      left: 12px;
      background: rgba(0,0,0,0.4);
      backdrop-filter: blur(6px);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 12px;
      line-height: 1.35;
      color: #e6e9ee;
      user-select: none;
      pointer-events: none;
      white-space: nowrap;
    }
    .overlay .hint { color: #9fb3c8; }
    .footer {
      position: fixed;
      right: 12px;
      bottom: 12px;
      font-size: 12px;
      color: #7f8b99;
      opacity: 0.8;
      user-select: none;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="app"></div>
  <div class="overlay">
    <div><strong>Network Landscape</strong> — moving viewport</div>
    <div class="hint">Drag to orbit, scroll to zoom, right-drag to pan</div>
  </div>
  <div class="footer">Clipped view window sweeps the field over time</div>

  <!-- Three.js (UMD builds so it works from a local file with internet access) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  (function() {
    const container = document.getElementById('app');
    const overlayHint = document.querySelector('.overlay .hint');
    const footer = document.querySelector('.footer');

    function setModeLabel(label) {
      if (footer) footer.textContent = `Clipped view window sweeps the field over time — ${label}`;
    }

    function startThree() {
      // Scene & Renderer
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x020305, 0.003);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearAlpha(0);
      renderer.localClippingEnabled = true;
      container.appendChild(renderer.domElement);

      // Camera & Controls
      const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(80, 70, 90);
      const controls = (THREE.OrbitControls) ? new THREE.OrbitControls(camera, renderer.domElement) : null;
      if (controls) {
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 500;
        controls.maxPolarAngle = Math.PI * 0.495;
      } else if (overlayHint) {
        overlayHint.textContent = 'Use mouse to explore (OrbitControls unavailable)';
      }

      // Lights
      const hemiLight = new THREE.HemisphereLight(0x6fa4ff, 0x0b0c0f, 0.9);
      scene.add(hemiLight);
      const dirLight = new THREE.DirectionalLight(0xa6c8ff, 1.2);
      dirLight.position.set(60, 100, 40);
      scene.add(dirLight);

      // Parameters for the grid landscape
      const gridCount = 120;            // nodes per side
      const spacing = 1.0;              // world units between nodes
      const halfExtent = (gridCount - 1) * spacing * 0.5;
      const baseColorNodes = new THREE.Color('#a8c8ff');
      const baseColorLines = new THREE.Color('#5aa7ff');

      // Height function to shape the landscape (no external noise dependency)
      function heightFn(x, z) {
        const s1 = Math.sin(x * 0.08) * Math.cos(z * 0.08);
        const s2 = Math.sin(x * 0.021 + 1.7) * Math.cos(z * 0.024 - 0.6);
        const s3 = Math.sin(x * 0.012 - 2.3) * Math.cos(z * 0.010 + 1.1);
        return (s1 * 8.0) + (s2 * 4.0) + (s3 * 2.5);
      }

      // Build node positions
      const nodePositions = new Float32Array(gridCount * gridCount * 3);
      let p = 0;
      for (let iz = 0; iz < gridCount; iz++) {
        for (let ix = 0; ix < gridCount; ix++) {
          const x = ix * spacing - halfExtent;
          const z = iz * spacing - halfExtent;
          const y = heightFn(x, z);
          nodePositions[p++] = x;
          nodePositions[p++] = y;
          nodePositions[p++] = z;
        }
      }

      // Points (nodes)
      const pointsGeometry = new THREE.BufferGeometry();
      pointsGeometry.setAttribute('position', new THREE.BufferAttribute(nodePositions, 3));
      const pointsMaterial = new THREE.PointsMaterial({
        size: 2.6,
        sizeAttenuation: true,
        color: baseColorNodes,
        transparent: true,
        opacity: 0.95,
        depthWrite: false
      });
      const points = new THREE.Points(pointsGeometry, pointsMaterial);
      scene.add(points);

      // Line segments (connections)
      const segments = (gridCount * (gridCount - 1)) * 2; // right and down per cell row/col
      const linePositions = new Float32Array(segments * 3 * 2); // two endpoints per segment
      let lp = 0;
      function writeVertex(ix, iz) {
        const idx = (iz * gridCount + ix) * 3;
        linePositions[lp++] = nodePositions[idx];
        linePositions[lp++] = nodePositions[idx + 1];
        linePositions[lp++] = nodePositions[idx + 2];
      }
      for (let iz = 0; iz < gridCount; iz++) {
        for (let ix = 0; ix < gridCount; ix++) {
          if (ix + 1 < gridCount) {
            writeVertex(ix, iz);
            writeVertex(ix + 1, iz);
          }
          if (iz + 1 < gridCount) {
            writeVertex(ix, iz);
            writeVertex(ix, iz + 1);
          }
        }
      }
      const linesGeometry = new THREE.BufferGeometry();
      linesGeometry.setAttribute('position', new THREE.BufferAttribute(linePositions, 3));
      const linesMaterial = new THREE.LineBasicMaterial({
        color: baseColorLines,
        transparent: true,
        opacity: 0.45,
        linewidth: 1
      });
      const lineSegments = new THREE.LineSegments(linesGeometry, linesMaterial);
      scene.add(lineSegments);

      // Ground reference grid (very light)
      const gridHelper = new THREE.GridHelper(gridCount * spacing, gridCount, 0x1b2a3a, 0x101820);
      gridHelper.position.y = -20;
      gridHelper.material.opacity = 0.12;
      gridHelper.material.transparent = true;
      scene.add(gridHelper);

      // Moving clipping window (axis-aligned rectangular slab)
      const windowHalfSize = Math.max(12, gridCount * spacing * 0.14);
      let windowCenterX = 0;
      let windowCenterZ = 0;

      const planeXMax = new THREE.Plane(new THREE.Vector3(1, 0, 0), - (windowCenterX + windowHalfSize));
      const planeXMin = new THREE.Plane(new THREE.Vector3(-1, 0, 0), (windowCenterX - windowHalfSize));
      const planeZMax = new THREE.Plane(new THREE.Vector3(0, 0, 1), - (windowCenterZ + windowHalfSize));
      const planeZMin = new THREE.Plane(new THREE.Vector3(0, 0, -1), (windowCenterZ - windowHalfSize));
      const clippingPlanes = [planeXMax, planeXMin, planeZMax, planeZMin];

      pointsMaterial.clippingPlanes = clippingPlanes;
      linesMaterial.clippingPlanes = clippingPlanes;

      const originalNodePositions = nodePositions.slice();

      const clock = new THREE.Clock();
      function animate() {
        const t = clock.getElapsedTime();

        const radius = halfExtent * 0.5;
        windowCenterX = Math.sin(t * 0.25) * radius * 0.85;
        windowCenterZ = Math.cos(t * 0.31) * radius * 0.85;

        planeXMax.constant = - (windowCenterX + windowHalfSize);
        planeXMin.constant = (windowCenterX - windowHalfSize);
        planeZMax.constant = - (windowCenterZ + windowHalfSize);
        planeZMin.constant = (windowCenterZ - windowHalfSize);

        const shimmer = Math.sin(t * 0.9) * 0.6;
        for (let i = 0; i < nodePositions.length; i += 3) {
          nodePositions[i + 1] = originalNodePositions[i + 1] + shimmer;
        }
        pointsGeometry.attributes.position.needsUpdate = true;

        let lpIndex = 0;
        function writeLineVertex(ix, iz) {
          const idx = (iz * gridCount + ix) * 3;
          linePositions[lpIndex++] = originalNodePositions[idx];
          linePositions[lpIndex++] = originalNodePositions[idx + 1] + shimmer;
          linePositions[lpIndex++] = originalNodePositions[idx + 2];
        }
        lpIndex = 0;
        for (let iz = 0; iz < gridCount; iz++) {
          for (let ix = 0; ix < gridCount; ix++) {
            if (ix + 1 < gridCount) {
              writeLineVertex(ix, iz);
              writeLineVertex(ix + 1, iz);
            }
            if (iz + 1 < gridCount) {
              writeLineVertex(ix, iz);
              writeLineVertex(ix, iz + 1);
            }
          }
        }
        linesGeometry.attributes.position.needsUpdate = true;

        if (controls) controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      function addStars(count) {
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
          const r = 800 + Math.random() * 1200;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(2 * Math.random() - 1);
          starPos[i * 3 + 0] = r * Math.sin(phi) * Math.cos(theta);
          starPos[i * 3 + 1] = r * Math.cos(phi) + 300;
          starPos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
        const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.4, sizeAttenuation: true, opacity: 0.8, transparent: true });
        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);
      }
      addStars(1200);

      setModeLabel('3D mode');
    }

    function startCanvas2D() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      const canvas = document.createElement('canvas');
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      canvas.style.display = 'block';
      container.appendChild(canvas);
      const ctx = canvas.getContext('2d');

      function resize() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        canvas.width = Math.floor(w * dpr);
        canvas.height = Math.floor(h * dpr);
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }
      window.addEventListener('resize', resize);
      resize();

      const gridCount = 110;
      const spacing = 1.0;
      const halfExtent = (gridCount - 1) * spacing * 0.5;
      const scale = 8.0; // pixels per world unit

      function heightFn(x, z) {
        const s1 = Math.sin(x * 0.08) * Math.cos(z * 0.08);
        const s2 = Math.sin(x * 0.021 + 1.7) * Math.cos(z * 0.024 - 0.6);
        const s3 = Math.sin(x * 0.012 - 2.3) * Math.cos(z * 0.010 + 1.1);
        return (s1 * 8.0) + (s2 * 4.0) + (s3 * 2.5);
      }

      const nodes = new Float32Array(gridCount * gridCount * 3);
      let p = 0;
      for (let iz = 0; iz < gridCount; iz++) {
        for (let ix = 0; ix < gridCount; ix++) {
          const x = ix * spacing - halfExtent;
          const z = iz * spacing - halfExtent;
          const y = heightFn(x, z);
          nodes[p++] = x;
          nodes[p++] = y;
          nodes[p++] = z;
        }
      }
      const nodesOriginal = nodes.slice();

      function project(x, y, z, w, h) {
        const sx = x * scale + w * 0.5;
        const sy = (z * scale * 0.5) - (y * scale * 0.9) + h * 0.55;
        return [sx, sy];
      }

      function inWindow(x, z, cx, cz, w) {
        return (x >= cx - w && x <= cx + w && z >= cz - w && z <= cz + w);
      }

      let windowCenterX = 0;
      let windowCenterZ = 0;
      const windowHalfSize = Math.max(12, gridCount * spacing * 0.14);

      function render(t) {
        const w = canvas.width / dpr;
        const h = canvas.height / dpr;
        ctx.clearRect(0, 0, w, h);

        // Move window center
        const radius = halfExtent * 0.5;
        windowCenterX = Math.sin(t * 0.00025) * radius * 0.85;
        windowCenterZ = Math.cos(t * 0.00031) * radius * 0.85;

        // Shimmer
        const shimmer = Math.sin(t * 0.0009) * 0.6;
        for (let i = 0; i < nodes.length; i += 3) {
          nodes[i + 1] = nodesOriginal[i + 1] + shimmer;
        }

        // Draw connections inside window
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.45;
        ctx.strokeStyle = '#5aa7ff';
        ctx.beginPath();
        for (let iz = 0; iz < gridCount; iz++) {
          for (let ix = 0; ix < gridCount; ix++) {
            const idx = (iz * gridCount + ix) * 3;
            const x = nodes[idx];
            const y = nodes[idx + 1];
            const z = nodes[idx + 2];
            const insideA = inWindow(x, z, windowCenterX, windowCenterZ, windowHalfSize);
            if (ix + 1 < gridCount) {
              const idxB = (iz * gridCount + (ix + 1)) * 3;
              const xb = nodes[idxB];
              const yb = nodes[idxB + 1];
              const zb = nodes[idxB + 2];
              const insideB = inWindow(xb, zb, windowCenterX, windowCenterZ, windowHalfSize);
              if (insideA && insideB) {
                const [sx, sy] = project(x, y, z, w, h);
                const [sx2, sy2] = project(xb, yb, zb, w, h);
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx2, sy2);
              }
            }
            if (iz + 1 < gridCount) {
              const idxC = ((iz + 1) * gridCount + ix) * 3;
              const xc = nodes[idxC];
              const yc = nodes[idxC + 1];
              const zc = nodes[idxC + 2];
              const insideC = inWindow(xc, zc, windowCenterX, windowCenterZ, windowHalfSize);
              if (insideA && insideC) {
                const [sx, sy] = project(x, y, z, w, h);
                const [sx3, sy3] = project(xc, yc, zc, w, h);
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx3, sy3);
              }
            }
          }
        }
        ctx.stroke();

        // Draw nodes inside window
        ctx.globalAlpha = 0.95;
        for (let iz = 0; iz < gridCount; iz++) {
          for (let ix = 0; ix < gridCount; ix++) {
            const idx = (iz * gridCount + ix) * 3;
            const x = nodes[idx];
            const y = nodes[idx + 1];
            const z = nodes[idx + 2];
            if (!inWindow(x, z, windowCenterX, windowCenterZ, windowHalfSize)) continue;
            const [sx, sy] = project(x, y, z, w, h);
            const radius = 1.8 + (y * 0.02);
            ctx.fillStyle = '#a8c8ff';
            ctx.beginPath();
            ctx.arc(sx, sy, Math.max(0.6, radius), 0, Math.PI * 2);
            ctx.fill();
          }
        }

        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);

      if (overlayHint) {
        overlayHint.textContent = '2D fallback active';
      }
      setModeLabel('2D fallback');
    }

    // Try to start Three.js; if not available, use 2D fallback
    try {
      if (window.THREE && typeof THREE.WebGLRenderer === 'function') {
        startThree();
      } else {
        startCanvas2D();
      }
    } catch (err) {
      console.warn('Three.js failed to initialize, switching to 2D fallback:', err);
      startCanvas2D();
    }
  })();
  </script>
</body>
</html>

